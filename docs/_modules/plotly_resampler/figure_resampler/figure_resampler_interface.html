
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>plotly_resampler.figure_resampler.figure_resampler_interface &#8212; plotly-resampler &#34;0.8.1&#34; documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/icon.png"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
    <img src="../../../_static/logo.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../_static/logo.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../getting_started.html">
  Get started üöÄ
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../dash_app_integration.html">
  Dash apps ü§ù
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../api_reference.html">
  API üìñ
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../FAQ.html">
  FAQ ‚ùì
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/predict-idlab/plotly-resampler" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
      <div class="navbar-end-item">
        <form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for plotly_resampler.figure_resampler.figure_resampler_interface</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Abstract ``AbstractFigureAggregator`` interface for the concrete *Resampler* classes.</span>

<span class="sd">.. |br| raw:: html</span>

<span class="sd">   &lt;br&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Jonas Van Der Donckt, Jeroen Van Der Donckt, Emiel Deprost&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="kn">import</span> <span class="nn">dash</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">from</span> <span class="nn">plotly.basedatatypes</span> <span class="kn">import</span> <span class="n">BaseTraceType</span><span class="p">,</span> <span class="n">BaseFigure</span>

<span class="kn">from</span> <span class="nn">..aggregation</span> <span class="kn">import</span> <span class="n">AbstractSeriesAggregator</span><span class="p">,</span> <span class="n">EfficientLTTB</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">round_td_str</span><span class="p">,</span> <span class="n">round_number_str</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>

<span class="n">_hf_data_container</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;DataContainer&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;hovertext&quot;</span><span class="p">])</span>


<div class="viewcode-block" id="AbstractFigureAggregator"><a class="viewcode-back" href="../../../figure_resampler.html#plotly_resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator">[docs]</a><span class="k">class</span> <span class="nc">AbstractFigureAggregator</span><span class="p">(</span><span class="n">BaseFigure</span><span class="p">,</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract interface for data aggregation functionality for plotly figures.&quot;&quot;&quot;</span>

    <span class="n">_high_frequency_traces</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;scatter&quot;</span><span class="p">,</span> <span class="s2">&quot;scattergl&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="n">BaseFigure</span><span class="p">,</span>
        <span class="n">convert_existing_traces</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">default_n_shown_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">default_downsampler</span><span class="p">:</span> <span class="n">AbstractSeriesAggregator</span> <span class="o">=</span> <span class="n">EfficientLTTB</span><span class="p">(),</span>
        <span class="n">resampled_trace_prefix_suffix</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;&lt;b style=&quot;color:sandybrown&quot;&gt;[R]&lt;/b&gt; &#39;</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">show_mean_aggregation_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">convert_traces_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Instantiate a resampling data mirror.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figure: BaseFigure</span>
<span class="sd">            The figure that will be decorated. Can be either an empty figure</span>
<span class="sd">            (e.g., ``go.Figure()``, ``make_subplots()``, ``go.FigureWidget``) or an</span>
<span class="sd">            existing figure.</span>
<span class="sd">        convert_existing_traces: bool</span>
<span class="sd">            A bool indicating whether the high-frequency traces of the passed ``figure``</span>
<span class="sd">            should be resampled, by default True. Hence, when set to False, the</span>
<span class="sd">            high-frequency traces of the passed ``figure`` will not be resampled.</span>
<span class="sd">        default_n_shown_samples: int, optional</span>
<span class="sd">            The default number of samples that will be shown for each trace,</span>
<span class="sd">            by default 1000.\n</span>
<span class="sd">            .. note::</span>
<span class="sd">                * This can be overridden within the :func:`add_trace` method.</span>
<span class="sd">                * If a trace withholds fewer datapoints than this parameter,</span>
<span class="sd">                  the data will *not* be aggregated.</span>
<span class="sd">        default_downsampler: AbstractSeriesDownsampler</span>
<span class="sd">            An instance which implements the AbstractSeriesDownsampler interface and</span>
<span class="sd">            will be used as default downsampler, by default ``EfficientLTTB`` with</span>
<span class="sd">            _interleave_gaps_ set to True. \n</span>
<span class="sd">            .. note:: This can be overridden within the :func:`add_trace` method.</span>
<span class="sd">        resampled_trace_prefix_suffix: str, optional</span>
<span class="sd">            A tuple which contains the ``prefix`` and ``suffix``, respectively, which</span>
<span class="sd">            will be added to the trace its legend-name when a resampled version of the</span>
<span class="sd">            trace is shown. By default a bold, orange ``[R]`` is shown as prefix</span>
<span class="sd">            (no suffix is shown).</span>
<span class="sd">        show_mean_aggregation_size: bool, optional</span>
<span class="sd">            Whether the mean aggregation bin size will be added as a suffix to the trace</span>
<span class="sd">            its legend-name, by default True.</span>
<span class="sd">        convert_traces_kwargs: dict, optional</span>
<span class="sd">            A dict of kwargs that will be passed to the :func:`add_traces` method and</span>
<span class="sd">            will be used to convert the existing traces. \n</span>
<span class="sd">            .. note::</span>
<span class="sd">                This argument is only used when the passed ``figure`` contains data and</span>
<span class="sd">                ``convert_existing_traces`` is set to True.</span>
<span class="sd">        verbose: bool, optional</span>
<span class="sd">            Whether some verbose messages will be printed or not, by default False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_n_shown_samples</span> <span class="o">=</span> <span class="n">default_n_shown_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_show_mean_aggregation_size</span> <span class="o">=</span> <span class="n">show_mean_aggregation_size</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">resampled_trace_prefix_suffix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span> <span class="o">=</span> <span class="n">resampled_trace_prefix_suffix</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_global_downsampler</span> <span class="o">=</span> <span class="n">default_downsampler</span>

        <span class="c1"># Given figure should always be a BaseFigure that is not wrapped by</span>
        <span class="c1"># a plotly-resampler class</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">BaseFigure</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">figure</span><span class="p">),</span> <span class="n">AbstractFigureAggregator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_figure_class</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="vm">__class__</span>

        <span class="c1"># Overwrite the passed arguments with the property dict values</span>
        <span class="c1"># (this is the case when the PR figure is created from a pickled object)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="s2">&quot;_pr_props&quot;</span><span class="p">):</span>
            <span class="n">pr_props</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">_pr_props</span>  <span class="c1"># a dict of PR properties</span>
            <span class="k">if</span> <span class="n">pr_props</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Overwrite the default arguments with the serialized properties</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pr_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="s2">&quot;_pr_props&quot;</span><span class="p">)</span>  <span class="c1"># should not be stored anymore</span>

        <span class="k">if</span> <span class="n">convert_existing_traces</span><span class="p">:</span>
            <span class="c1"># call __init__ with the correct layout and set the `_grid_ref` of the</span>
            <span class="c1"># to-be-converted figure</span>
            <span class="n">f_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_figure_class</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="n">figure</span><span class="o">.</span><span class="n">layout</span><span class="p">)</span>
            <span class="n">f_</span><span class="o">.</span><span class="n">_grid_str</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">_grid_str</span>
            <span class="n">f_</span><span class="o">.</span><span class="n">_grid_ref</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">_grid_ref</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">f_</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">convert_traces_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">convert_traces_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># make sure that the UIDs of these traces do not get adjusted</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_validator</span><span class="o">.</span><span class="n">set_uid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span><span class="n">figure</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">convert_traces_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">figure</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_validator</span><span class="o">.</span><span class="n">set_uid</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># A list of al xaxis and yaxis string names</span>
        <span class="c1"># e.g., &quot;xaxis&quot;, &quot;xaxis2&quot;, &quot;xaxis3&quot;, .... for _xaxis_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xaxis_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;xaxis\d*&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_yaxis_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;yaxis\d*&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># edge case: an empty `go.Figure()` does not yet contain axes keys</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_xaxis_list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_xaxis_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;xaxis&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_yaxis_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;yaxis&quot;</span><span class="p">]</span>

        <span class="c1"># Make sure to reset the layout its range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">axis</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;autorange&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;range&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xaxis_list</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_yaxis_list</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper method for printing if ``verbose`` is set to True.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_print_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_query_hf_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Query the internal ``_hf_data`` attribute and returns a match based on</span>
<span class="sd">        ``uid``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trace : dict</span>
<span class="sd">            The trace where we want to find a match for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[dict]</span>
<span class="sd">            The ``hf_data``-trace dict if a match is found, else ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;uid&quot;</span><span class="p">]</span>
        <span class="n">hf_trace_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hf_trace_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trace_props</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">trace</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">})</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[W] trace with </span><span class="si">{</span><span class="n">trace_props</span><span class="si">}</span><span class="s2"> not found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hf_trace_data</span>

    <span class="k">def</span> <span class="nf">_get_current_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create an efficient copy of the current graph by omitting the &quot;hovertext&quot;,</span>
<span class="sd">        &quot;x&quot;, and &quot;y&quot; properties of each trace.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The current graph dict</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        https://github.com/plotly/plotly.py/blob/2e7f322c5ea4096ce6efe3b4b9a34d9647a8be9c/packages/python/plotly/plotly/basedatatypes.py#L3278</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">copy</span><span class="p">(</span><span class="n">trace</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;hovertext&quot;</span><span class="p">})</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="p">],</span>
            <span class="s2">&quot;layout&quot;</span><span class="p">:</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_layout</span><span class="p">),</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_check_update_trace_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">BaseTraceType</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Check and update the passed ``trace`` its data properties based on the</span>
<span class="sd">        slice range.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is a pass by reference. The passed trace object will be updated and</span>
<span class="sd">        returned if found in ``hf_data``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trace : BaseTraceType or dict</span>
<span class="sd">             - An instances of a trace class from the ``plotly.graph_objects`` (go)</span>
<span class="sd">                package (e.g, ``go.Scatter``, ``go.Bar``)</span>
<span class="sd">             - or a dict where:</span>

<span class="sd">                  - The &#39;type&#39; property specifies the trace type (e.g.</span>
<span class="sd">                    &#39;scatter&#39;, &#39;bar&#39;, &#39;area&#39;, etc.). If the dict has no &#39;type&#39;</span>
<span class="sd">                    property then &#39;scatter&#39; is assumed.</span>
<span class="sd">                  - All remaining properties are passed to the constructor</span>
<span class="sd">                    of the specified trace type.</span>

<span class="sd">        start : Union[float, str], optional</span>
<span class="sd">            The start index for which we want resampled data to be updated to,</span>
<span class="sd">            by default None,</span>
<span class="sd">        end : Union[float, str], optional</span>
<span class="sd">            The end index for which we want the resampled data to be updated to,</span>
<span class="sd">            by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[Union[dict, BaseTraceType]]</span>
<span class="sd">            If the matching ``hf_series`` is found in ``hf_dict``, an (updated) trace</span>
<span class="sd">            will be returned, otherwise None.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        * If ``start`` and ``stop`` are strings, they most likely represent time-strings</span>
<span class="sd">        * ``start`` and ``stop`` will always be of the same type (float / time-string)</span>
<span class="sd">           because their underlying axis is the same.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hf_trace_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_hf_data</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hf_trace_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis_type</span> <span class="o">=</span> <span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;axis_type&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">axis_type</span> <span class="o">==</span> <span class="s2">&quot;date&quot;</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                <span class="n">hf_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_time</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_to_hf_series</span><span class="p">(</span><span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]),</span>
                    <span class="n">start</span><span class="p">,</span>
                    <span class="n">end</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hf_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_hf_series</span><span class="p">(</span><span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hf_series</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">hf_series</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="n">hf_series</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">end</span>
                    <span class="k">if</span> <span class="n">hf_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
                        <span class="n">end</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

                    <span class="c1"># Search the index-positions</span>
                    <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">hf_series</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span>
                    <span class="n">hf_series</span> <span class="o">=</span> <span class="n">hf_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>

            <span class="c1"># Return an invisible, single-point, trace when the sliced hf_series doesn&#39;t</span>
            <span class="c1"># contain any data in the current view</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hf_series</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;hovertext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">return</span> <span class="n">trace</span>

            <span class="c1"># Downsample the data and store it in the trace-fields</span>
            <span class="n">downsampler</span><span class="p">:</span> <span class="n">AbstractSeriesAggregator</span> <span class="o">=</span> <span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;downsampler&quot;</span><span class="p">]</span>
            <span class="n">s_res</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">=</span> <span class="n">downsampler</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
                <span class="n">hf_series</span><span class="p">,</span> <span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;max_n_samples&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_res</span><span class="o">.</span><span class="n">index</span>
            <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_res</span><span class="o">.</span><span class="n">values</span>
            <span class="c1"># todo -&gt; first draft &amp; not MP safe</span>

            <span class="n">agg_prefix</span><span class="p">,</span> <span class="n">agg_suffix</span> <span class="o">=</span> <span class="s1">&#39; &lt;i style=&quot;color:#fc9944&quot;&gt;~&#39;</span><span class="p">,</span> <span class="s2">&quot;&lt;/i&gt;&quot;</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">agg_prefix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hf_series</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;max_n_samples&quot;</span><span class="p">]:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">)</span> <span class="o">+</span> <span class="n">name</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="c1"># Add the mean aggregation bin size to the trace name</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show_mean_aggregation_size</span><span class="p">:</span>
                    <span class="n">agg_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">s_res</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg_mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">):</span>
                        <span class="n">agg_mean</span> <span class="o">=</span> <span class="n">round_td_str</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">agg_mean</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">agg_mean</span> <span class="o">=</span> <span class="n">round_number_str</span><span class="p">(</span><span class="n">agg_mean</span><span class="p">)</span>
                    <span class="n">name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">agg_prefix</span><span class="si">}{</span><span class="n">agg_mean</span><span class="si">}{</span><span class="n">agg_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># When not resampled: trim prefix and/or suffix if necessary</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">)</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span><span class="p">)</span> <span class="ow">and</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span><span class="p">)]</span>
            <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>

            <span class="c1"># Check if text also needs to be resampled</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">hf_trace_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;text&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
                <span class="c1"># TODO -&gt; extra logic is necessary for the detection and processing of</span>
                <span class="c1"># non data-point selection downsamplers</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_hf_series</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">text</span><span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
                    <span class="n">s_res</span><span class="o">.</span><span class="n">index</span>
                <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span>

            <span class="c1"># Check if hovertext also needs to be resampled</span>
            <span class="n">hovertext</span> <span class="o">=</span> <span class="n">hf_trace_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hovertext&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hovertext</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;hovertext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_hf_series</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">hf_trace_data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">hovertext</span>
                <span class="p">)</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">s_res</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;hovertext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hovertext</span>
            <span class="k">return</span> <span class="n">trace</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="s2">&quot;hf_data not found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_update_figure_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">figure</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xaxis_filter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">updated_trace_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Check and update the traces within the figure dict.</span>

<span class="sd">        hint</span>
<span class="sd">        ----</span>
<span class="sd">        This method will most likely be used within a ``Dash`` callback to resample the</span>
<span class="sd">        view, based on the configured number of parameters.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This is a pass by reference. The passed figure object will be updated.</span>
<span class="sd">        No new view of this figure will be created, hence no return!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figure : dict</span>
<span class="sd">            The figure dict which will be updated.</span>
<span class="sd">        start : Union[float, str], optional</span>
<span class="sd">            The start time for the new resampled data view, by default None.</span>
<span class="sd">        stop : Union[float, str], optional</span>
<span class="sd">            The end time for the new resampled data view, by default None.</span>
<span class="sd">        xaxis_filter: str, optional</span>
<span class="sd">            Additional trace-update subplot filter, by default None.</span>
<span class="sd">        updated_trace_indices: List[int], optional</span>
<span class="sd">            List of trace indices that already have been updated, by default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[int]</span>
<span class="sd">            A list of indices withholding the trace-data-array-index from the of data</span>
<span class="sd">            modalities which are updated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xaxis_filter_short</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">xaxis_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xaxis_filter_short</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span> <span class="o">+</span> <span class="n">xaxis_filter</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;xaxis&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">updated_trace_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">updated_trace_indices</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">trace</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">figure</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]):</span>
            <span class="c1"># We skip when the trace-idx already has been updated.</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">updated_trace_indices</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">xaxis_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># the x-anchor of the trace is stored in the layout data</span>
                <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;yaxis&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># no yaxis -&gt; we make the assumption that yaxis = xaxis_filter_short</span>
                    <span class="n">y_axis</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span> <span class="o">+</span> <span class="n">xaxis_filter</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_axis</span> <span class="o">=</span> <span class="s2">&quot;yaxis&quot;</span> <span class="o">+</span> <span class="n">trace</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;yaxis&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="c1"># Next to the x-anchor, we also fetch the xaxis which matches the</span>
                <span class="c1"># current trace (i.e. if this value is not None, the axis shares the</span>
                <span class="c1"># x-axis with one or more traces).</span>
                <span class="c1"># This is relevant when e.g. fig.update_traces(xaxis=&#39;x...&#39;) was called.</span>
                <span class="n">x_anchor_trace</span> <span class="o">=</span> <span class="n">figure</span><span class="p">[</span><span class="s2">&quot;layout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">y_axis</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;anchor&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">x_anchor_trace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">xaxis_matches</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">figure</span><span class="p">[</span><span class="s2">&quot;layout&quot;</span><span class="p">]</span>
                        <span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;xaxis&quot;</span> <span class="o">+</span> <span class="n">x_anchor_trace</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="p">{})</span>
                        <span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;matches&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xaxis_matches</span> <span class="o">=</span> <span class="n">figure</span><span class="p">[</span><span class="s2">&quot;layout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;xaxis&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;matches&quot;</span><span class="p">)</span>

                <span class="c1"># print(</span>
                <span class="c1">#     f&quot;x_anchor: {x_anchor_trace} - xaxis_filter: {xaxis_filter} &quot;,</span>
                <span class="c1">#     f&quot;- xaxis_matches: {xaxis_matches}&quot;</span>
                <span class="c1"># )</span>

                <span class="c1"># We skip when:</span>
                <span class="c1"># * the change was made on the first row and the trace its anchor is not</span>
                <span class="c1">#   in [None, &#39;x&#39;] and the matching (a.k.a. shared) xaxis is not equal</span>
                <span class="c1">#   to the xaxis filter argument.</span>
                <span class="c1">#   -&gt; why None: traces without row/col argument and stand on first row</span>
                <span class="c1">#      and do not have the anchor property (hence the DICT.get() method)</span>
                <span class="c1"># * x_axis_filter_short not in [x_anchor or xaxis matches] for</span>
                <span class="c1">#   NON first rows</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">xaxis_filter_short</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span>
                    <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">x_anchor_trace</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">]</span>
                        <span class="ow">and</span> <span class="n">xaxis_matches</span> <span class="o">!=</span> <span class="n">xaxis_filter_short</span>
                    <span class="p">)</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">xaxis_filter_short</span> <span class="o">!=</span> <span class="s2">&quot;x&quot;</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="n">xaxis_filter_short</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x_anchor_trace</span><span class="p">,</span> <span class="n">xaxis_matches</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="k">continue</span>

            <span class="c1"># If we managed to find and update the trace, it will return the trace</span>
            <span class="c1"># and thus not None.</span>
            <span class="n">updated_trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_update_trace_data</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">updated_trace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">updated_trace_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">updated_trace_indices</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_figure_class</span><span class="p">(</span><span class="n">constr</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">type</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the plotly figure class (constructor) for the given class (constructor).</span>

<span class="sd">        .. Note::</span>
<span class="sd">            This method will always return a plotly constructor, even when the given</span>
<span class="sd">            `constr` is decorated (after executing the ``register_plotly_resampler``</span>
<span class="sd">            function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        constr: type</span>
<span class="sd">            The constructor class for which we want to retrieve the plotly constructor.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        type:</span>
<span class="sd">            The plotly figure class (constructor) of the given `constr`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">..registering</span> <span class="kn">import</span> <span class="n">_get_plotly_constr</span>  <span class="c1"># To avoid ImportError</span>

        <span class="k">return</span> <span class="n">_get_plotly_constr</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_slice_time</span><span class="p">(</span>
        <span class="n">hf_series</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
        <span class="n">t_start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">t_stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Slice the time-indexed ``hf_series`` for the passed pd.Timestamps.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This returns a **view** of ``hf_series``!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hf_series: pd.Series</span>
<span class="sd">            The **datetime-indexed** series, which will be sliced.</span>
<span class="sd">        t_start: pd.Timestamp, optional</span>
<span class="sd">            The lower-time-bound of the slice, if set to None, no lower-bound threshold</span>
<span class="sd">            will be applied, by default None.</span>
<span class="sd">        t_stop:  pd.Timestamp, optional</span>
<span class="sd">            The upper time-bound of the slice, if set to None, no upper-bound threshold</span>
<span class="sd">            will be applied, by default None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Series</span>
<span class="sd">            The sliced **view** of the series.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">to_same_tz</span><span class="p">(</span>
            <span class="n">ts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">reference_tz</span><span class="o">=</span><span class="n">hf_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="sd">&quot;&quot;&quot;Adjust `ts` its timezone to the `reference_tz`.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">reference_tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">ts</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">zone</span> <span class="o">==</span> <span class="n">reference_tz</span><span class="o">.</span><span class="n">zone</span>
                    <span class="k">return</span> <span class="n">ts</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># localize -&gt; time remains the same</span>
                    <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="n">reference_tz</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">reference_tz</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ts</span><span class="o">.</span><span class="n">tz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ts</span>

        <span class="k">if</span> <span class="n">t_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t_stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">t_start</span><span class="o">.</span><span class="n">tz</span> <span class="o">==</span> <span class="n">t_stop</span><span class="o">.</span><span class="n">tz</span>

        <span class="k">return</span> <span class="n">hf_series</span><span class="p">[</span><span class="n">to_same_tz</span><span class="p">(</span><span class="n">t_start</span><span class="p">)</span> <span class="p">:</span> <span class="n">to_same_tz</span><span class="p">(</span><span class="n">t_stop</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hf_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Property to adjust the `data` component of the current graph</span>

<span class="sd">        .. note::</span>
<span class="sd">            The user has full responsibility to adjust ``hf_data`` properly.</span>


<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; fig = FigureResampler(go.Figure())</span>
<span class="sd">            &gt;&gt;&gt; fig.add_trace(...)</span>
<span class="sd">            &gt;&gt;&gt; fig.hf_data[-1][&quot;y&quot;] = - s ** 2  # adjust the y-property of the trace added above</span>
<span class="sd">            &gt;&gt;&gt; fig.hf_data</span>
<span class="sd">            [</span>
<span class="sd">                {</span>
<span class="sd">                    &#39;max_n_samples&#39;: 1000,</span>
<span class="sd">                    &#39;x&#39;: RangeIndex(start=0, stop=11000000, step=1),</span>
<span class="sd">                    &#39;y&#39;: array([-0.01339909,  0.01390696,, ...,  0.25051913, 0.55876513]),</span>
<span class="sd">                    &#39;axis_type&#39;: &#39;linear&#39;,</span>
<span class="sd">                    &#39;downsampler&#39;: &lt;plotly_resampler.aggregation.aggregators.LTTB at 0x7f786d5a9ca0&gt;,</span>
<span class="sd">                    &#39;text&#39;: None,</span>
<span class="sd">                    &#39;hovertext&#39;: None</span>
<span class="sd">                },</span>
<span class="sd">            ]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_to_hf_series</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Construct the hf-series.</span>

<span class="sd">        By constructing the hf-series this way, users can dynamically adjust the hf</span>
<span class="sd">        series argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : np.ndarray</span>
<span class="sd">            The hf_series index</span>
<span class="sd">        y : np.ndarray</span>
<span class="sd">            The hf_series values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.Series</span>
<span class="sd">            The constructed hf_series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note this is the same behavior as plotly support</span>
        <span class="c1"># i.e. it also used the `values` property of the `x` and `y` parameters when</span>
        <span class="c1"># these are pd.Series</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">values</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">values</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;category&quot;</span> <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span> <span class="k">else</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parse_get_trace_props</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="n">BaseTraceType</span><span class="p">,</span>
        <span class="n">hf_x</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hf_y</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hf_text</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hf_hovertext</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_hf_data_container</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Parse and capture the possibly high-frequency trace-props in a datacontainer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trace : BaseTraceType</span>
<span class="sd">            The trace which will be parsed.</span>
<span class="sd">        hf_x : Iterable, optional</span>
<span class="sd">            high-frequency trace &quot;x&quot; data, overrides the current trace its x-data.</span>
<span class="sd">        hf_y : Iterable, optional</span>
<span class="sd">            high-frequency trace &quot;y&quot; data, overrides the current trace its y-data.</span>
<span class="sd">        hf_text : Iterable, optional</span>
<span class="sd">            high-frequency trace &quot;text&quot; data, overrides the current trace its text-data.</span>
<span class="sd">        hf_hovertext : Iterable, optional</span>
<span class="sd">            high-frequency trace &quot;hovertext&quot; data, overrides the current trace its</span>
<span class="sd">            hovertext data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _hf_data_container</span>
<span class="sd">            A namedtuple which serves as a datacontainer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hf_x</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hf_x</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">hf_x</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">hf_x</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hf_x</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">hf_y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hf_y</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_y</span><span class="p">,</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">))</span>
            <span class="k">else</span> <span class="n">hf_y</span>
        <span class="p">)</span>
        <span class="n">hf_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hf_y</span><span class="p">)</span>

        <span class="n">hf_text</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">hf_text</span>
            <span class="k">if</span> <span class="n">hf_text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="n">hf_hovertext</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">hf_hovertext</span>
            <span class="k">if</span> <span class="n">hf_hovertext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;hovertext&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;hovertext&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;hovertext&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="kc">None</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_frequency_traces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hf_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if no data as x or hf_x is passed</span>
                <span class="k">if</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if hf_y is an array</span>
                    <span class="n">hf_x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">RangeIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">hf_y</span><span class="p">))</span>  <span class="c1"># np.arange(len(hf_y))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># if no data as y or hf_y is passed</span>
                    <span class="n">hf_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">hf_x</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;plotly-resampler requires scatter data &quot;</span>
                <span class="s2">&quot;(i.e., x and y, or hf_x and hf_y) to have the same dimensionality!&quot;</span>
            <span class="p">)</span>
            <span class="c1"># When the x or y of a trace has more than 1 dimension, it is not at all</span>
            <span class="c1"># straightforward how it should be resampled.</span>
            <span class="k">assert</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">hf_x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;plotly-resampler requires scatter data &quot;</span>
                <span class="s2">&quot;(i.e., x and y, or hf_x and hf_y) to be &lt;= 1 dimensional!&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Note: this also converts hf_text and hf_hovertext to a np.ndarray</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_text</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
                <span class="n">hf_text</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hf_text</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_hovertext</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">)):</span>
                <span class="n">hf_hovertext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hf_hovertext</span><span class="p">)</span>

            <span class="c1"># Remove NaNs for efficiency (storing less meaningless data)</span>
            <span class="c1"># NaNs introduce gaps between enclosing non-NaN data points &amp; might distort</span>
            <span class="c1"># the resampling algorithms</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">hf_y</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">not_nan_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">hf_y</span><span class="p">)</span>
                <span class="n">hf_x</span> <span class="o">=</span> <span class="n">hf_x</span><span class="p">[</span><span class="n">not_nan_mask</span><span class="p">]</span>
                <span class="n">hf_y</span> <span class="o">=</span> <span class="n">hf_y</span><span class="p">[</span><span class="n">not_nan_mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_text</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">hf_text</span> <span class="o">=</span> <span class="n">hf_text</span><span class="p">[</span><span class="n">not_nan_mask</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hf_hovertext</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">hf_hovertext</span> <span class="o">=</span> <span class="n">hf_hovertext</span><span class="p">[</span><span class="n">not_nan_mask</span><span class="p">]</span>

            <span class="c1"># If the categorical or string-like hf_y data is of type object (happens</span>
            <span class="c1"># when y argument is used for the trace constructor instead of hf_y), we</span>
            <span class="c1"># transform it to type string as such it will be sent as categorical data</span>
            <span class="c1"># to the downsampling algorithm</span>
            <span class="k">if</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;object&quot;</span><span class="p">:</span>
                <span class="c1"># But first, we try to parse to a numeric dtype (as this is the</span>
                <span class="c1"># behavior that plotly supports)</span>
                <span class="c1"># Note that a bool array of type object will remain a bool array (and</span>
                <span class="c1"># not will be transformed to an array of ints (0, 1))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">hf_y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span><span class="n">hf_y</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">hf_y</span> <span class="o">=</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">)</span>

            <span class="c1"># orjson encoding doesn&#39;t like to encode with uint8 &amp; uint16 dtype</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">hf_y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;uint8&quot;</span><span class="p">,</span> <span class="s2">&quot;uint16&quot;</span><span class="p">]:</span>
                <span class="n">hf_y</span> <span class="o">=</span> <span class="n">hf_y</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">hf_x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">hf_y</span><span class="p">),</span> <span class="s2">&quot;x and y have different length!&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;trace </span><span class="si">{</span><span class="n">trace</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> is not a high-frequency trace&quot;</span><span class="p">)</span>

            <span class="c1"># hf_x and hf_y have priority over the traces&#39; data</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">):</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hf_x</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">):</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hf_y</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">):</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hf_text</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="s2">&quot;hovertext&quot;</span><span class="p">):</span>
                <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;hovertext&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hf_hovertext</span>

        <span class="k">return</span> <span class="n">_hf_data_container</span><span class="p">(</span><span class="n">hf_x</span><span class="p">,</span> <span class="n">hf_y</span><span class="p">,</span> <span class="n">hf_text</span><span class="p">,</span> <span class="n">hf_hovertext</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_construct_hf_data_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dc</span><span class="p">:</span> <span class="n">_hf_data_container</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="n">BaseTraceType</span><span class="p">,</span>
        <span class="n">downsampler</span><span class="p">:</span> <span class="n">AbstractSeriesAggregator</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create the `hf_data` dict which will be put in the `_hf_data` property.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dc : _hf_data_container</span>
<span class="sd">            The hf_data container, withholding the parsed hf-data.</span>
<span class="sd">        trace : BaseTraceType</span>
<span class="sd">            The trace.</span>
<span class="sd">        downsampler : AbstractSeriesAggregator | None</span>
<span class="sd">            The downsampler which will be used.</span>
<span class="sd">        max_n_samples : int | None</span>
<span class="sd">            The max number of output samples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The hf_data dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We will re-create this each time as hf_x and hf_y withholds</span>
        <span class="c1"># high-frequency data and can be adjusted on the fly with the public hf_data</span>
        <span class="c1"># property.</span>
        <span class="n">hf_series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_hf_series</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">dc</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">dc</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Checking this now avoids less interpretable `KeyError` when resampling</span>
        <span class="k">assert</span> <span class="n">hf_series</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_monotonic_increasing</span>

        <span class="c1"># As we support prefix-suffixing of downsampled data, we assure that</span>
        <span class="c1"># each trace has a name</span>
        <span class="c1"># https://github.com/plotly/plotly.py/blob/ce0ed07d872c487698bde9d52e1f1aadf17aa65f/packages/python/plotly/plotly/basedatatypes.py#L539</span>
        <span class="c1"># The link above indicates that the trace index is derived from `data`</span>
        <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;trace </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Determine (1) the axis type and (2) the downsampler instance</span>
        <span class="c1"># &amp; (3) store a hf_data entry for the corresponding trace,</span>
        <span class="c1"># identified by its UUID</span>
        <span class="n">axis_type</span> <span class="o">=</span> <span class="s2">&quot;date&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dc</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;linear&quot;</span>

        <span class="n">default_n_samples</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">max_n_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default_n_samples</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">max_n_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_n_shown_samples</span>

        <span class="n">default_downsampler</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">downsampler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">default_downsampler</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">downsampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_downsampler</span>

        <span class="c1"># TODO -&gt; can&#39;t we just store the DC here (might be less duplication of</span>
        <span class="c1">#  code knowledge, because now, you need to know all the eligible hf_keys in</span>
        <span class="c1">#  dc</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;max_n_samples&quot;</span><span class="p">:</span> <span class="n">max_n_samples</span><span class="p">,</span>
            <span class="s2">&quot;default_n_samples&quot;</span><span class="p">:</span> <span class="n">default_n_samples</span><span class="p">,</span>
            <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">dc</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">dc</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="s2">&quot;axis_type&quot;</span><span class="p">:</span> <span class="n">axis_type</span><span class="p">,</span>
            <span class="s2">&quot;downsampler&quot;</span><span class="p">:</span> <span class="n">downsampler</span><span class="p">,</span>
            <span class="s2">&quot;default_downsampler&quot;</span><span class="p">:</span> <span class="n">default_downsampler</span><span class="p">,</span>
            <span class="s2">&quot;text&quot;</span><span class="p">:</span> <span class="n">dc</span><span class="o">.</span><span class="n">text</span><span class="p">,</span>
            <span class="s2">&quot;hovertext&quot;</span><span class="p">:</span> <span class="n">dc</span><span class="o">.</span><span class="n">hovertext</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_add_trace_to_add_traces_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert the `add_trace` kwargs to the `add_traces` kwargs.&quot;&quot;&quot;</span>
        <span class="c1"># The keywords that need to be converted to a list</span>
        <span class="n">convert_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;row&quot;</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;secondary_y&quot;</span><span class="p">]</span>

        <span class="n">updated_kwargs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># The updated kwargs (from `add_trace` to `add_traces`)</span>
        <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">convert_keywords</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">updated_kwargs</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">updated_kwargs</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">keyword</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    
        <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">updated_kwargs</span><span class="p">}</span>


<div class="viewcode-block" id="AbstractFigureAggregator.add_trace"><a class="viewcode-back" href="../../../figure_resampler.html#plotly_resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_trace">[docs]</a>    <span class="k">def</span> <span class="nf">add_trace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trace</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">BaseTraceType</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span>
        <span class="n">max_n_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downsampler</span><span class="p">:</span> <span class="n">AbstractSeriesAggregator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit_to_view</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="c1"># Use these if you want some speedups (and are working with really large data)</span>
        <span class="n">hf_x</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hf_y</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hf_text</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">hf_hovertext</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">trace_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a trace to the figure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trace : BaseTraceType or dict</span>
<span class="sd">            Either:</span>

<span class="sd">              - An instances of a trace class from the ``plotly.graph_objects`` (go)</span>
<span class="sd">                package (e.g., ``go.Scatter``, ``go.Bar``)</span>
<span class="sd">              - or a dict where:</span>

<span class="sd">                - The type property specifies the trace type (e.g. scatter, bar,</span>
<span class="sd">                  area, etc.). If the dict has no &#39;type&#39; property then scatter is</span>
<span class="sd">                  assumed.</span>
<span class="sd">                - All remaining properties are passed to the constructor</span>
<span class="sd">                  of the specified trace type.</span>
<span class="sd">        max_n_samples : int, optional</span>
<span class="sd">            The maximum number of samples that will be shown by the trace.\n</span>
<span class="sd">            .. note::</span>
<span class="sd">                If this variable is not set; ``_global_n_shown_samples`` will be used.</span>
<span class="sd">        downsampler: AbstractSeriesDownsampler, optional</span>
<span class="sd">            The abstract series downsampler method.\n</span>
<span class="sd">            .. note::</span>
<span class="sd">                If this variable is not set, ``_global_downsampler`` will be used.</span>
<span class="sd">        limit_to_view: boolean, optional</span>
<span class="sd">            If set to True the trace&#39;s datapoints will be cut to the corresponding</span>
<span class="sd">            front-end view, even if the total number of samples is lower than</span>
<span class="sd">            ``max_n_samples``, By default False.\n</span>
<span class="sd">            Remark that setting this parameter to True ensures that low frequency traces</span>
<span class="sd">            are added to the ``hf_data`` property.</span>
<span class="sd">        hf_x: Iterable, optional</span>
<span class="sd">            The original high frequency series positions, can be either a time-series or</span>
<span class="sd">            an increasing, numerical index. If set, this has priority over the trace its</span>
<span class="sd">            data.</span>
<span class="sd">        hf_y: Iterable, optional</span>
<span class="sd">            The original high frequency values. If set, this has priority over the</span>
<span class="sd">            trace its data.</span>
<span class="sd">        hf_text: Iterable, optional</span>
<span class="sd">            The original high frequency text. If set, this has priority over the trace</span>
<span class="sd">            its ``text`` argument.</span>
<span class="sd">        hf_hovertext: Iterable, optional</span>
<span class="sd">            The original high frequency hovertext. If set, this has priority over the</span>
<span class="sd">            trace its ```hovertext`` argument.</span>
<span class="sd">        **trace_kwargs: dict</span>
<span class="sd">            Additional trace related keyword arguments.</span>
<span class="sd">            e.g.: row=.., col=..., secondary_y=...</span>

<span class="sd">            .. seealso::</span>
<span class="sd">                `Figure.add_trace &lt;https://plotly.com/python-api-reference/generated/plotly.graph_objects.Figure.html#plotly.graph_objects.Figure.add_trace&gt;`_ docs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseFigure</span>
<span class="sd">            The Figure on which ``add_trace`` was called on; i.e. self.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Constructing traces with **very large data amounts** really takes some time.</span>
<span class="sd">        To speed this up; use this :func:`add_trace` method and</span>

<span class="sd">        1. Create a trace with no data (empty lists)</span>
<span class="sd">        2. pass the high frequency data to this method using the ``hf_x`` and ``hf_y``</span>
<span class="sd">           parameters.</span>

<span class="sd">        See the example below:</span>

<span class="sd">            &gt;&gt;&gt; from plotly.subplots import make_subplots</span>
<span class="sd">            &gt;&gt;&gt; s = pd.Series()  # a high-frequency series, with more than 1e7 samples</span>
<span class="sd">            &gt;&gt;&gt; fig = FigureResampler(go.Figure())</span>
<span class="sd">            &gt;&gt;&gt; fig.add_trace(go.Scattergl(x=[], y=[], ...), hf_x=s.index, hf_y=s)</span>

<span class="sd">        .. todo::</span>
<span class="sd">            * explain why adding x and y to a trace is so slow</span>
<span class="sd">            * check and simplify the example above</span>

<span class="sd">        Tip</span>
<span class="sd">        ---</span>
<span class="sd">        * If you **do not want to downsample** your data, set ``max_n_samples`` to the</span>
<span class="sd">          the number of datapoints of your trace!</span>

<span class="sd">        Attention</span>
<span class="sd">        ---------</span>
<span class="sd">        * The ``NaN`` values in either ``hf_y`` or ``trace.y`` will be omitted! We do</span>
<span class="sd">          not allow ``NaN`` values in ``hf_x`` or ``trace.x``.</span>
<span class="sd">        * ``hf_x``, ``hf_y``, ``hf_text``, and ``hf_hovertext`` are useful when you deal</span>
<span class="sd">          with large amounts of data (as it can increase the speed of this add_trace()</span>
<span class="sd">          method with ~30%). These arguments have priority over the trace&#39;s data and</span>
<span class="sd">          (hover)text attributes.</span>
<span class="sd">        * Low-frequency time-series data, i.e. traces that are not resampled, can hinder</span>
<span class="sd">          the the automatic-zooming (y-scaling) as these will not be stored in the</span>
<span class="sd">          back-end and thus not be scaled to the view.</span>
<span class="sd">          To circumvent this, the ``limit_to_view`` argument can be set, resulting in</span>
<span class="sd">          also storing the low-frequency series in the back-end.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># to comply with the plotly data input acceptance behavior</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trace must be either a dict or a BaseTraceType&quot;</span><span class="p">)</span>

        <span class="n">max_out_s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_global_n_shown_samples</span> <span class="k">if</span> <span class="n">max_n_samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_n_samples</span>
        <span class="p">)</span>

        <span class="c1"># Validate the trace and convert to a trace object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">BaseTraceType</span><span class="p">):</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_validator</span><span class="o">.</span><span class="n">validate_coerce</span><span class="p">(</span><span class="n">trace</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># First add an UUID, as each (even the non-hf_data traces), must contain this</span>
        <span class="c1"># key for comparison. If the trace already has an UUID, we will keep it.</span>
        <span class="n">uuid_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">())</span> <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">trace</span><span class="o">.</span><span class="n">uid</span>
        <span class="n">trace</span><span class="o">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uuid_str</span>

        <span class="c1"># construct the hf_data_container</span>
        <span class="c1"># TODO in future version -&gt; maybe regex on kwargs which start with `hf_`</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_get_trace_props</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">hf_x</span><span class="p">,</span> <span class="n">hf_y</span><span class="p">,</span> <span class="n">hf_text</span><span class="p">,</span> <span class="n">hf_hovertext</span><span class="p">)</span>

        <span class="c1"># These traces will determine the autoscale RANGE!</span>
        <span class="c1">#   -&gt; so also store when `limit_to_view` is set.</span>
        <span class="k">if</span> <span class="n">trace</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_frequency_traces</span><span class="p">:</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dc</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_samples</span> <span class="o">&gt;</span> <span class="n">max_out_s</span> <span class="ow">or</span> <span class="n">limit_to_view</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">[i] DOWNSAMPLE </span><span class="si">{</span><span class="n">trace</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">max_out_s</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span><span class="p">[</span><span class="n">uuid_str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_hf_data_dict</span><span class="p">(</span>
                    <span class="n">dc</span><span class="p">,</span>
                    <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">,</span>
                    <span class="n">downsampler</span><span class="o">=</span><span class="n">downsampler</span><span class="p">,</span>
                    <span class="n">max_n_samples</span><span class="o">=</span><span class="n">max_n_samples</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Before we update the trace, we create a new pointer to that trace in</span>
                <span class="c1"># which the downsampled data will be stored. This way, the original</span>
                <span class="c1"># data of the trace to this `add_trace` method will not be altered.</span>
                <span class="c1"># We copy (by reference) all the non-data properties of the trace in</span>
                <span class="c1"># the new trace.</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">_props</span>  <span class="c1"># convert the trace into a dict</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">trace</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dc</span><span class="o">.</span><span class="n">_fields</span><span class="p">))</span>
                <span class="p">}</span>

                <span class="c1"># NOTE:</span>
                <span class="c1"># If all the raw data needs to be sent to the javascript, and the trace</span>
                <span class="c1"># is high-frequency, this would take significant time!</span>
                <span class="c1"># Hence, you first downsample the trace.</span>
                <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_update_trace_data</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">trace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbstractFigureAggregator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">trace</span><span class="p">],</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_trace_to_add_traces_kwargs</span><span class="p">(</span><span class="n">trace_kwargs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[i] NOT resampling </span><span class="si">{</span><span class="n">trace</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> - len=</span><span class="si">{</span><span class="n">n_samples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># TODO: can be made more generic</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">dc</span><span class="o">.</span><span class="n">x</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">dc</span><span class="o">.</span><span class="n">y</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">dc</span><span class="o">.</span><span class="n">text</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">hovertext</span> <span class="o">=</span> <span class="n">dc</span><span class="o">.</span><span class="n">hovertext</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbstractFigureAggregator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">trace</span><span class="p">],</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_trace_to_add_traces_kwargs</span><span class="p">(</span><span class="n">trace_kwargs</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbstractFigureAggregator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span>
            <span class="p">[</span><span class="n">trace</span><span class="p">],</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_trace_to_add_traces_kwargs</span><span class="p">(</span><span class="n">trace_kwargs</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AbstractFigureAggregator.add_traces"><a class="viewcode-back" href="../../../figure_resampler.html#plotly_resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.add_traces">[docs]</a>    <span class="k">def</span> <span class="nf">add_traces</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">BaseTraceType</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">|</span> <span class="n">BaseTraceType</span> <span class="o">|</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">max_n_samples</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downsamplers</span><span class="p">:</span> <span class="kc">None</span>
        <span class="o">|</span> <span class="n">List</span><span class="p">[</span><span class="n">AbstractSeriesAggregator</span><span class="p">]</span>
        <span class="o">|</span> <span class="n">AbstractFigureAggregator</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit_to_views</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">traces_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add traces to the figure.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Make sure to look at the :func:`add_trace` function for more info about</span>
<span class="sd">            **speed optimization**, and dealing with not ``high-frequency`` data, but</span>
<span class="sd">            still want to resample / limit the data to the front-end view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : List[BaseTraceType  |  dict]</span>
<span class="sd">            A list of trace specifications to be added.</span>
<span class="sd">            Trace specifications may be either:</span>

<span class="sd">              - Instances of trace classes from the plotly.graph_objs</span>
<span class="sd">                package (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar).</span>
<span class="sd">              - Dicts where:</span>

<span class="sd">                  - The &#39;type&#39; property specifies the trace type (e.g.</span>
<span class="sd">                    &#39;scatter&#39;, &#39;bar&#39;, &#39;area&#39;, etc.). If the dict has no &#39;type&#39;</span>
<span class="sd">                    property then &#39;scatter&#39; is assumed.</span>
<span class="sd">                  - All remaining properties are passed to the constructor</span>
<span class="sd">                    of the specified trace type.</span>

<span class="sd">        max_n_samples : None | List[int] | int, optional</span>
<span class="sd">              The maximum number of samples that will be shown for each trace.</span>
<span class="sd">              If a single integer is passed, all traces will use this number. If this</span>
<span class="sd">              variable is not set; ``_global_n_shown_samples`` will be used.</span>
<span class="sd">        downsamplers : None | List[AbstractSeriesAggregator] | AbstractFigureAggregator, optional</span>
<span class="sd">            The downsampler that will be used to aggregate the traces. If a single</span>
<span class="sd">            aggregator is passed, all traces will use this aggregator.</span>
<span class="sd">            If this variable is not set, ``_global_downsampler`` will be used.</span>
<span class="sd">        limit_to_views : None | List[bool] | bool, optional</span>
<span class="sd">            List of limit_to_view booleans for the added traces.  If set to True</span>
<span class="sd">            the trace&#39;s datapoints will be cut to the corresponding front-end view,</span>
<span class="sd">            even if the total number of samples is lower than ``max_n_samples``. If a</span>
<span class="sd">            single boolean is passed, all to be added traces will use this value,</span>
<span class="sd">            by default False.\n</span>
<span class="sd">            Remark that setting this parameter to True ensures that low frequency traces</span>
<span class="sd">            are added to the ``hf_data`` property.</span>
<span class="sd">        **traces_kwargs: dict</span>
<span class="sd">            Additional trace related keyword arguments.</span>
<span class="sd">            e.g.: rows=.., cols=..., secondary_ys=...</span>

<span class="sd">            .. seealso::</span>
<span class="sd">                `Figure.add_traces &lt;https://plotly.com/python-api-reference/generated/plotly.graph_objects.Figure.html#plotly.graph_objects.Figure.add_traces&gt;`_ docs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BaseFigure</span>
<span class="sd">            The Figure on which ``add_traces`` was called on; i.e. self.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># note: Plotly its add_traces also a allows non list-like input e.g. a scatter</span>
        <span class="c1"># object; the code below is an exact copy of their internally applied parsing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>

        <span class="c1"># Convert each trace into a BaseTraceType object</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_validator</span><span class="o">.</span><span class="n">validate_coerce</span><span class="p">(</span><span class="n">trace</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">BaseTraceType</span><span class="p">)</span>
            <span class="k">else</span> <span class="n">trace</span>
            <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">data</span>
        <span class="p">]</span>

        <span class="c1"># First add an UUID, as each (even the non-hf_data traces), must contain this</span>
        <span class="c1"># key for comparison. If the trace already has an UUID, we will keep it.</span>
        <span class="k">for</span> <span class="n">trace</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">uuid_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">())</span> <span class="k">if</span> <span class="n">trace</span><span class="o">.</span><span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">trace</span><span class="o">.</span><span class="n">uid</span>
            <span class="n">trace</span><span class="o">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uuid_str</span>

        <span class="c1"># Convert the data properties</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_n_samples</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">or</span> <span class="n">max_n_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_n_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_n_samples</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">downsamplers</span><span class="p">,</span> <span class="n">AbstractSeriesAggregator</span><span class="p">)</span> <span class="ow">or</span> <span class="n">downsamplers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">downsamplers</span> <span class="o">=</span> <span class="p">[</span><span class="n">downsamplers</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">limit_to_views</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">limit_to_views</span> <span class="o">=</span> <span class="p">[</span><span class="n">limit_to_views</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">trace</span><span class="p">,</span> <span class="n">max_out</span><span class="p">,</span> <span class="n">downsampler</span><span class="p">,</span> <span class="n">limit_to_view</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">max_n_samples</span><span class="p">,</span> <span class="n">downsamplers</span><span class="p">,</span> <span class="n">limit_to_views</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">trace</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_high_frequency_traces</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">max_out_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_n_shown_samples</span> <span class="k">if</span> <span class="n">max_out</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_out</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_to_view</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_out_s</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_get_trace_props</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span><span class="p">[</span><span class="n">trace</span><span class="o">.</span><span class="n">uid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_hf_data_dict</span><span class="p">(</span>
                <span class="n">dc</span><span class="p">,</span>
                <span class="n">trace</span><span class="o">=</span><span class="n">trace</span><span class="p">,</span>
                <span class="n">downsampler</span><span class="o">=</span><span class="n">downsampler</span><span class="p">,</span>
                <span class="n">max_n_samples</span><span class="o">=</span><span class="n">max_out</span><span class="p">,</span>
                <span class="n">offset</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># convert the trace into a dict, and only withholds the non-hf props</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span><span class="o">.</span><span class="n">_props</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">trace</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">trace</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dc</span><span class="o">.</span><span class="n">_fields</span><span class="p">))}</span>

            <span class="c1"># update the trace data with the HF props</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_update_trace_data</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">trace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trace</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_figure_class</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">traces_kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_clear_figure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear the current figure object it&#39;s data and layout.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hf_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layout</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_copy_hf_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hf_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">adjust_default_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Copy (i.e. create a new key reference, not a deep copy) of a hf_data dict.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hf_data : dict</span>
<span class="sd">            The hf_data dict, having the trace &#39;uid&#39; as key and the</span>
<span class="sd">            hf-data, together with its aggregation properties as dict-values</span>
<span class="sd">        adjust_default_values: bool</span>
<span class="sd">            Whether the default values (of the downsampler, max # shown samples) will</span>
<span class="sd">            be adjusted according to the values of this object, by default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The copied (&amp; default values adjusted) output dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hf_data_cp</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">uid</span><span class="p">:</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">hf_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">hf_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>
            <span class="k">for</span> <span class="n">uid</span><span class="p">,</span> <span class="n">hf_dict</span> <span class="ow">in</span> <span class="n">hf_data</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># Adjust the default arguments to the current argument values</span>
        <span class="k">if</span> <span class="n">adjust_default_values</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hf_props</span> <span class="ow">in</span> <span class="n">hf_data_cp</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">hf_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default_downsampler&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">hf_props</span><span class="p">[</span><span class="s2">&quot;downsampler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_downsampler</span>
                <span class="k">if</span> <span class="n">hf_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default_n_samples&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                    <span class="n">hf_props</span><span class="p">[</span><span class="s2">&quot;max_n_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_global_n_shown_samples</span>

        <span class="k">return</span> <span class="n">hf_data_cp</span>

<div class="viewcode-block" id="AbstractFigureAggregator.replace"><a class="viewcode-back" href="../../../figure_resampler.html#plotly_resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figure</span><span class="p">:</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">convert_existing_traces</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Replace the current figure layout with the passed figure object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figure: go.Figure</span>
<span class="sd">            The figure object which will replace the existing figure.</span>
<span class="sd">        convert_existing_traces: bool, Optional</span>
<span class="sd">            A bool indicating whether the traces of the passed ``figure`` should be</span>
<span class="sd">            resampled, by default True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_figure</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">figure</span><span class="o">=</span><span class="n">figure</span><span class="p">,</span>
            <span class="n">convert_existing_traces</span><span class="o">=</span><span class="n">convert_existing_traces</span><span class="p">,</span>
            <span class="n">default_n_shown_samples</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_global_n_shown_samples</span><span class="p">,</span>
            <span class="n">default_downsampler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_global_downsampler</span><span class="p">,</span>
            <span class="n">resampled_trace_prefix_suffix</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_suffix</span><span class="p">),</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AbstractFigureAggregator.construct_update_data"><a class="viewcode-back" href="../../../figure_resampler.html#plotly_resampler.figure_resampler.figure_resampler_interface.AbstractFigureAggregator.construct_update_data">[docs]</a>    <span class="k">def</span> <span class="nf">construct_update_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">relayout_data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">dash</span><span class="o">.</span><span class="n">no_update</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Construct the to-be-updated front-end data, based on the layout change.</span>

<span class="sd">        Attention</span>
<span class="sd">        ---------</span>
<span class="sd">        This method is tightly coupled with Dash app callbacks. It takes the front-end</span>
<span class="sd">        figure its ``relayoutData`` as input and returns the data which needs to be</span>
<span class="sd">        sent tot the ``TraceUpdater`` its ``updateData`` property for that corresponding</span>
<span class="sd">        graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        relayout_data: dict</span>
<span class="sd">            A dict containing the ``relayout``-data (a.k.a. changed layout data) of</span>
<span class="sd">            the corresponding front-end graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[dict]:</span>
<span class="sd">            A list of dicts, where each dict-item is a representation of a trace its</span>
<span class="sd">            *data* properties which are affected by the front-end layout change. |br|</span>
<span class="sd">            In other words, only traces which need to be updated will be sent to the</span>
<span class="sd">            front-end. Additionally, each trace-dict withholds the *index* of its</span>
<span class="sd">            corresponding position in the ``figure[data]`` array with the ``index``-key</span>
<span class="sd">            in each dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_current_graph</span><span class="p">()</span>
        <span class="n">updated_trace_indices</span><span class="p">,</span> <span class="n">cl_k</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">relayout_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;changed layout&quot;</span><span class="p">,</span> <span class="n">relayout_data</span><span class="p">)</span>

            <span class="n">cl_k</span> <span class="o">=</span> <span class="n">relayout_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

            <span class="c1"># ------------------ HF DATA aggregation ---------------------</span>
            <span class="c1"># 1. Base case - there is a x-range specified in the front-end</span>
            <span class="n">start_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xaxis\d*.range\[0]&quot;</span><span class="p">),</span> <span class="n">cl_k</span><span class="p">)</span>
            <span class="n">stop_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xaxis\d*.range\[1]&quot;</span><span class="p">),</span> <span class="n">cl_k</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_matches</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stop_matches</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">t_start_key</span><span class="p">,</span> <span class="n">t_stop_key</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start_matches</span><span class="p">,</span> <span class="n">stop_matches</span><span class="p">):</span>
                    <span class="c1"># Check if the xaxis&lt;NUMB&gt; part of xaxis&lt;NUMB&gt;.[0-1] matches</span>
                    <span class="n">xaxis</span> <span class="o">=</span> <span class="n">t_start_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">xaxis</span> <span class="o">==</span> <span class="n">t_stop_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># -&gt; we want to copy the layout on the back-end</span>
                    <span class="n">updated_trace_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_update_figure_dict</span><span class="p">(</span>
                        <span class="n">current_graph</span><span class="p">,</span>
                        <span class="n">start</span><span class="o">=</span><span class="n">relayout_data</span><span class="p">[</span><span class="n">t_start_key</span><span class="p">],</span>
                        <span class="n">stop</span><span class="o">=</span><span class="n">relayout_data</span><span class="p">[</span><span class="n">t_stop_key</span><span class="p">],</span>
                        <span class="n">xaxis_filter</span><span class="o">=</span><span class="n">xaxis</span><span class="p">,</span>
                        <span class="n">updated_trace_indices</span><span class="o">=</span><span class="n">updated_trace_indices</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># 2. The user clicked on either autorange | reset axes</span>
            <span class="n">autorange_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span>
                <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xaxis\d*.autorange&quot;</span><span class="p">),</span> <span class="n">cl_k</span>
            <span class="p">)</span>
            <span class="n">spike_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;xaxis\d*.showspikes&quot;</span><span class="p">),</span> <span class="n">cl_k</span><span class="p">)</span>
            <span class="c1"># 2.1 Reset-axes -&gt; autorange &amp; reset to the global data view</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">autorange_matches</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_matches</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">autorange_key</span> <span class="ow">in</span> <span class="n">autorange_matches</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">relayout_data</span><span class="p">[</span><span class="n">autorange_key</span><span class="p">]:</span>
                        <span class="n">xaxis</span> <span class="o">=</span> <span class="n">autorange_key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">updated_trace_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_update_figure_dict</span><span class="p">(</span>
                            <span class="n">current_graph</span><span class="p">,</span>
                            <span class="n">xaxis_filter</span><span class="o">=</span><span class="n">xaxis</span><span class="p">,</span>
                            <span class="n">updated_trace_indices</span><span class="o">=</span><span class="n">updated_trace_indices</span><span class="p">,</span>
                        <span class="p">)</span>
            <span class="c1"># 2.1. Autorange -&gt; do nothing, the autorange will be applied on the</span>
            <span class="c1">#      current front-end view</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">autorange_matches</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_matches</span><span class="p">):</span>
                <span class="c1"># PreventUpdate returns a 204 status code response on the</span>
                <span class="c1"># relayout post request</span>
                <span class="k">return</span> <span class="n">dash</span><span class="o">.</span><span class="n">no_update</span>

        <span class="c1"># If we do not have any traces to be updated, we will return an empty</span>
        <span class="c1"># request response</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">updated_trace_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># PreventUpdate returns a 204 status-code response on the relayout post</span>
            <span class="c1"># request</span>
            <span class="k">return</span> <span class="n">dash</span><span class="o">.</span><span class="n">no_update</span>

        <span class="c1"># -------------------- construct callback data --------------------------</span>
        <span class="n">layout_traces_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the data</span>

        <span class="c1"># 1. Create a new dict with additional layout updates for the front-end</span>
        <span class="n">extra_layout_updates</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># 1.1. Set autorange to False for each layout item with a specified x-range</span>
        <span class="n">xy_matches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_re_matches</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[xy]axis\d*.range\[\d+]&quot;</span><span class="p">),</span> <span class="n">cl_k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">range_change_axis</span> <span class="ow">in</span> <span class="n">xy_matches</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">range_change_axis</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">extra_layout_updates</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">.autorange&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">layout_traces_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra_layout_updates</span><span class="p">)</span>

        <span class="c1"># 2. Create the additional trace data for the frond-end</span>
        <span class="n">relevant_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;hovertext&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">]</span>  <span class="c1"># TODO - marker color</span>
        <span class="c1"># Note that only updated trace-data will be sent to the client</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">updated_trace_indices</span><span class="p">:</span>
            <span class="n">trace</span> <span class="o">=</span> <span class="n">current_graph</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">trace_reduced</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">trace</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">relevant_keys</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">trace</span><span class="p">}</span>

            <span class="c1"># Store the index into the corresponding to-be-sent trace-data so</span>
            <span class="c1"># the client front-end can know which trace needs to be updated</span>
            <span class="n">trace_reduced</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">idx</span><span class="p">})</span>
            <span class="n">layout_traces_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trace_reduced</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">layout_traces_list</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_re_matches</span><span class="p">(</span><span class="n">regex</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">,</span> <span class="n">strings</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns all the items in ``strings`` which regex.match(es) ``regex``.&quot;&quot;&quot;</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_no_update</span><span class="p">(</span><span class="n">update_data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">dash</span><span class="o">.</span><span class="n">no_update</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">update_data</span> <span class="ow">is</span> <span class="n">dash</span><span class="o">.</span><span class="n">no_update</span>

    <span class="c1">## Magic methods (to use plotly.py words :grin:)</span>

    <span class="k">def</span> <span class="nf">_get_pr_props_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns the keys (i.e., the names) of the plotly-resampler properties.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method is used to serialize the object in the `__reduce__` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s2">&quot;_hf_data&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_global_n_shown_samples&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_print_verbose&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_show_mean_aggregation_size&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_prefix&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_suffix&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_global_downsampler&quot;</span><span class="p">,</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overwrite the reduce method (which is used to support deep copying and</span>
<span class="sd">        pickling).</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        We do not overwrite the `to_dict` method, as this is used to send the figure</span>
<span class="sd">        to the frontend (and thus should not capture the plotly-resampler properties).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">props</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">props</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># I don&#39;t know why this would be &gt; 1</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Add the plotly-resampler properties</span>
        <span class="n">props</span><span class="p">[</span><span class="s2">&quot;pr_props&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_pr_props_keys</span><span class="p">():</span>
            <span class="n">props</span><span class="p">[</span><span class="s2">&quot;pr_props&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">(</span><span class="n">props</span><span class="p">,))</span>  <span class="c1"># (props,) to comply with plotly magic</span></div>
</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2022, Jonas Van Der Donckt.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>